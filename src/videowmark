#!/bin/bash


# auto detect codec and bitrate from input stream, generate ffmpeg options for audio encoder
function audio_encode_options
{
  ffprobe -v quiet -print_format compact -show_streams "$1" | grep codec_type=audio | awk -F'|' '$1 == "stream" {
    for (i = 0; i < NF; i++)
      print $i
  }' | awk -F= '
    $1 == "codec_name" {
      codec = $2;

      # opus encoder is experimental, ffmpeg recommends libopus for encoding
      if (codec == "opus")
        codec = "libopus";

      printf (" -c:a %s", codec);
    }
    $1 == "bit_rate" {
      bit_rate = $2;

      if (bit_rate != "N/A")
        printf (" -ab %s", bit_rate);
    }'
}

function create_temp_files
{
  local fd

  for fd in "$@"
  do
    local tmpfile=$(mktemp /tmp/videowmark.XXXXXX)
    eval "exec $fd>$tmpfile"
    rm "$tmpfile"
  done
}

GETOPT_TEMP=`getopt -o v --long verbose,key:, -n 'videowmark' -- "$@"`

[ $? != 0 ] && exit 1 # exit on option parser errors

eval set -- "$GETOPT_TEMP"

AUDIOWMARK_KEY=()
FFMPEG_VERBOSE="-v error"
while true; do
  case "$1" in
    -v | --verbose ) FFMPEG_VERBOSE="-v info"; shift ;;
    --key ) AUDIOWMARK_KEY=("--key" "$2"); shift 2 ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

if [ "$1" == "add" ]; then
  # create tmpfiles
  create_temp_files 3 4
  orig_wav=/dev/fd/3
  wm_wav=/dev/fd/4

  # get audio as wav
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -f wav "$orig_wav"
  # watermark
  audiowmark "${AUDIOWMARK_KEY[@]}" add "$orig_wav" "$wm_wav" "$4"
  # rejoin
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -i "$wm_wav" -c:v copy $(audio_encode_options "$2") -map 0:v:0 -map 1:a:0 "$3"
elif [ "$1" == "get" ]; then
  # create tmpfiles
  create_temp_files 3
  wav=/dev/fd/3

  # get audio as wav
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -f wav "$wav"
  # get watermark
  audiowmark "${AUDIOWMARK_KEY[@]}" get "$wav"
elif [ "$1" == "probe" ]; then
  echo $2 $(audio_encode_options "$2")
else
  echo "videowmark: error parsing command line arguments"
fi
