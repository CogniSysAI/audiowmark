#!/bin/bash


function die
{
  echo >&2 "videowmark: error: $@"
  exit 1
}

# auto detect codec and bitrate from input stream, generate ffmpeg options for audio encoder
function audio_encode_options
{
  ffprobe -v quiet -print_format compact -show_streams "$1" | grep codec_type=audio | awk -F'|' '$1 == "stream" {
    for (i = 0; i < NF; i++)
      print $i
  }' | awk -F= '
    $1 == "codec_name" {
      codec = $2;

      # opus encoder is experimental, ffmpeg recommends libopus for encoding
      if (codec == "opus")
        codec = "libopus";

      printf (" -c:a %s", codec);
    }
    $1 == "bit_rate" {
      bit_rate = $2;

      if (bit_rate != "N/A")
        printf (" -ab %s", bit_rate);
    }'
}

function create_temp_files
{
  local fd

  for fd in "$@"
  do
    local tmpfile=$(mktemp /tmp/videowmark.XXXXXX)
    eval "exec $fd>$tmpfile"
    rm "$tmpfile"
  done
}

function show_help_and_exit
{
cat << EOH
usage: videowmark <command> [ <args>... ]

Commands:
  * create a watermarked video file with a message
    videowmark add <input_video> <watermarked_video> <message_hex>

  * retrieve message
    videowmark get <watermarked_video>

Global options:
  --strength <s>        set watermark strength
  --key <file>          load watermarking key from file
  -q, --quiet           disable information messages
  -v, --verbose         enable ffmpeg verbose output
EOH
exit 0
}

GETOPT_TEMP=`getopt -o vhq --long verbose,quiet,help,key:,strength: -n 'videowmark' -- "$@"`

[ $? != 0 ] && exit 1 # exit on option parser errors

eval set -- "$GETOPT_TEMP"

AUDIOWMARK_ARGS=()
FFMPEG_VERBOSE="-v error"
QUIET=""
export AV_LOG_FORCE_NOCOLOR=1 # disable colored messages from ffmpeg
while true; do
  case "$1" in
    -v | --verbose ) FFMPEG_VERBOSE="-v info"; shift ;;
    -q | --quiet ) AUDIOWMARK_ARGS+=("-q"); QUIET=1; shift ;;
    -h | --help ) show_help_and_exit ;;
    --key ) AUDIOWMARK_ARGS+=("--key" "$2"); shift 2 ;;
    --strength ) AUDIOWMARK_ARGS+=("--strength" "$2"); shift 2 ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

if [ "$1" == "add" ]; then
  # create tmpfiles
  create_temp_files 3 4
  orig_wav=/dev/fd/3
  wm_wav=/dev/fd/4

  # get audio as wav
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -f wav "$orig_wav" || die "extracting audio from video failed (ffmpeg)"
  # watermark
  [ -z "$QUIET" ] && echo >&2 "Audio Codec: $(audio_encode_options "$2")"
  audiowmark "${AUDIOWMARK_ARGS[@]}" add "$orig_wav" "$wm_wav" "$4" || die "watermark generation failed (audiowmark)"
  # rejoin
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -i "$wm_wav" -c:v copy $(audio_encode_options "$2") -map 0:v:0 -map 1:a:0 "$3" || \
    die "merging video and watermarked audio failed (ffmpeg)"
elif [ "$1" == "get" ]; then
  # create tmpfiles
  create_temp_files 3
  wav=/dev/fd/3

  # get audio as wav
  ffmpeg $FFMPEG_VERBOSE -y -i "$2" -f wav "$wav" || die "extracting audio from video failed (ffmpeg)"
  # get watermark
  audiowmark "${AUDIOWMARK_ARGS[@]}" get "$wav" || die "retrieving watermark from audio failed (audiowmark)"
elif [ "$1" == "probe" ]; then
  echo $2 $(audio_encode_options "$2")
else
  echo "videowmark: error parsing command line arguments (use videowmark -h)"
fi
